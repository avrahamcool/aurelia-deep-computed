{"version":3,"file":"index.js","sources":["../../src/dependency.ts","../../src/computed-observer.ts","../../src/computed-expression.ts","../../src/index.ts"],"sourcesContent":["import {\r\n  ICollectionObserverSplice,\r\n} from 'aurelia-binding';\r\nimport {\r\n  IPropertyObserver,\r\n  ICollectionObserver,\r\n  IDependency,\r\n  IComputedObserver,\r\n  ICollectionDependency\r\n} from './definitions';\r\n\r\n/**@internal */\r\nexport const releaseDep = (dep: IDependency) => {\r\n  dep.release();\r\n};\r\n\r\n/**@internal */\r\nexport const observeDep = (dep: IDependency) => {\r\n  dep.observe();\r\n};\r\n\r\n// for Aurelia binding subscriber, a context is required if it's not a function\r\nconst objectPropDepContext = 'context:object_prop_dep';\r\nconst arrayDepContext = 'context:array_dep';\r\nconst setDepContext = 'context:set_dep';\r\nconst mapDepContext = 'context:map_dep';\r\n\r\nclass ObjectDependency implements IDependency {\r\n  deps: Map<string | number, IDependency> = new Map();\r\n  connected: boolean = false;\r\n  constructor(\r\n    public owner: IComputedObserver,\r\n    public parent: IDependency | null,\r\n    public value: object\r\n  ) { }\r\n\r\n  collect(): void {\r\n    const value = this.value;\r\n    Object.keys(value).forEach(prop => {\r\n      const propertyDep = new ObjectPropertyDependency(this.owner, this, prop, value[prop]);\r\n      this.deps.set(prop, propertyDep);\r\n      propertyDep.collect();\r\n    });\r\n  }\r\n\r\n  observe() {\r\n    this.deps.forEach(observeDep);\r\n    this.connected = true;\r\n  }\r\n\r\n  release(): void {\r\n    this.deps.forEach(releaseDep);\r\n    this.connected = false;\r\n  }\r\n}\r\n\r\nconst emptyMap = new Map<unknown, IDependency>();\r\n\r\nclass ObjectPropertyDependency implements IDependency {\r\n  // object property has only 1 dep, there's no need to create a map\r\n  // so use an empty map instead\r\n  deps = emptyMap;\r\n  observer: IPropertyObserver;\r\n  connected: boolean = false;\r\n\r\n  dep: IDependency;\r\n\r\n  constructor(\r\n    public owner: IComputedObserver,\r\n    public parent: ObjectDependency,\r\n    public property: string,\r\n    public value: any\r\n  ) {}\r\n\r\n  collect(): void {\r\n    this.dep = void 0;\r\n    const owner = this.owner;\r\n    const deep = owner.deep;\r\n    if (!deep) {\r\n      return;\r\n    }\r\n    const valueDep = getDependency(owner, this, this.value);\r\n    if (valueDep == null) {\r\n      return;\r\n    }\r\n    this.dep = valueDep;\r\n    valueDep.collect();\r\n  }\r\n\r\n  observe(): void {\r\n    let observer = this.observer;\r\n    if (observer == null) {\r\n      observer\r\n        = this.observer\r\n        = this\r\n          .owner\r\n          .observerLocator\r\n          .getObserver(this.parent.value, this.property);\r\n    }\r\n    observer.subscribe(objectPropDepContext, this);\r\n    const dep = this.dep;\r\n    if (dep != null) {\r\n      dep.observe();\r\n    }\r\n    this.connected = true;\r\n  }\r\n\r\n  release(): void {\r\n    const observer = this.observer;\r\n    if (observer != null) {\r\n      observer.unsubscribe(objectPropDepContext, this);\r\n      this.observer = void 0;\r\n    }\r\n    const dep = this.dep;\r\n    if (dep != null) {\r\n      dep.release();\r\n      this.dep = void 0;\r\n    }\r\n    this.connected = false;\r\n  }\r\n\r\n  call(): void {\r\n    // when property change\r\n    // 1. release all sub-deps\r\n    this.release();\r\n    // 2. re-evaluate the value\r\n    this.value = this.parent.value[this.property];\r\n    // 3. re-collect deps\r\n    this.collect();\r\n    this.observe();\r\n    // 4. notify the owner\r\n    this.owner.handleChange(this);\r\n  }\r\n}\r\n\r\nabstract class BaseCollectionDependency implements ICollectionDependency {\r\n\r\n  owner: IComputedObserver;\r\n  parent: IDependency | null;\r\n  value: any[] | Map<any, any> | Set<any>;\r\n\r\n  deps: Map<string | number, IDependency> = new Map();\r\n  observer: ICollectionObserver;\r\n  connected: boolean = false;\r\n\r\n  abstract subscribeContext: string;\r\n\r\n  abstract collect(): void;\r\n\r\n  abstract getObserver(): ICollectionObserver;\r\n\r\n  observe() {\r\n    let observer = this.observer;\r\n    if (observer == null) {\r\n      observer = this.observer = this.getObserver();\r\n    }\r\n    observer.subscribe(this.subscribeContext, this);\r\n    this.deps.forEach(observeDep);\r\n    this.connected = true;\r\n  }\r\n\r\n  release(): void {\r\n    const observer = this.observer;\r\n    if (observer != null) {\r\n      observer.unsubscribe(this.subscribeContext, this);\r\n      this.observer = void 0;\r\n    }\r\n    this.deps.forEach(releaseDep);\r\n    this.deps.clear();\r\n    this.connected = false;\r\n  }\r\n\r\n  // todo: more efficient dep recollection\r\n  call(context: string, changeRecords: ICollectionObserverSplice[]): void {\r\n    // when array is mutated\r\n    // 1. release\r\n    this.release();\r\n    // 2. recollect\r\n    this.collect();\r\n    this.observe();\r\n    // 3. notify owner\r\n    this.owner.handleChange(this);\r\n  }\r\n}\r\n\r\nclass ArrayDependency extends BaseCollectionDependency {\r\n\r\n  subscribeContext = arrayDepContext;\r\n\r\n  constructor(\r\n    public owner: IComputedObserver,\r\n    public parent: IDependency | null,\r\n    public value: any[]\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  getObserver(): ICollectionObserver {\r\n    return this\r\n      .owner\r\n      .observerLocator\r\n      .getArrayObserver(this.value);\r\n  }\r\n\r\n  collect(): void {\r\n    const owner = this.owner;\r\n    const deep = owner.deep;\r\n    const deps = this.deps;\r\n    if (!deep) {\r\n      return;\r\n    }\r\n    for (let i = 0, arr = this.value, ii = arr.length; ii > i; ++i) {\r\n      let value = arr[i];\r\n      const dep = getDependency(owner, this, value);\r\n      // if an index is not observable\r\n      // just ignore\r\n      if (dep == void 0) {\r\n        return;\r\n      }\r\n      const existingDep = deps.get(i);\r\n      if (existingDep) {\r\n        existingDep.release();\r\n      }\r\n      deps.set(i, dep);\r\n      dep.collect();\r\n    }\r\n  }\r\n}\r\n\r\nclass MapDependency extends BaseCollectionDependency {\r\n\r\n  subscribeContext = mapDepContext;\r\n\r\n  constructor(\r\n    public owner: IComputedObserver,\r\n    public parent: IDependency | null,\r\n    public value: Map<any, any>\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  getObserver(): ICollectionObserver {\r\n    return this\r\n      .owner\r\n      .observerLocator\r\n      .getMapObserver(this.value);\r\n  }\r\n\r\n  collect(): void {\r\n    const owner = this.owner;\r\n    const deep = owner.deep;\r\n    const deps = this.deps;\r\n    if (!deep) {\r\n      return;\r\n    }\r\n    this.value.forEach((value, key) => {\r\n      const dep = getDependency(owner, this, value);\r\n      if (dep == void 0) {\r\n        return;\r\n      }\r\n      const existingDep = deps.get(key);\r\n      if (existingDep) {\r\n        existingDep.release();\r\n      }\r\n      // incorrect to typings, but safe\r\n      deps.set(key, dep);\r\n      dep.collect();\r\n    });\r\n  }\r\n}\r\n\r\nclass SetDependency extends BaseCollectionDependency {\r\n\r\n  subscribeContext = setDepContext;\r\n\r\n  constructor(\r\n    public owner: IComputedObserver,\r\n    public parent: IDependency | null,\r\n    public value: Set<any>\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  getObserver(): ICollectionObserver {\r\n    return this\r\n      .owner\r\n      .observerLocator\r\n      .getSetObserver(this.value);\r\n  }\r\n\r\n  collect(): void {\r\n    const owner = this.owner;\r\n    const deep = owner.deep;\r\n    const deps = this.deps;\r\n    if (!deep) {\r\n      return;\r\n    }\r\n    this.value.forEach(value => {\r\n      const dep = getDependency(owner, this, value);\r\n      if (dep == void 0) {\r\n        return;\r\n      }\r\n      const existingDep = deps.get(value);\r\n      if (existingDep) {\r\n        existingDep.release();\r\n      }\r\n      deps.set(value, dep);\r\n      if (deep) {\r\n        dep.collect();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport function getDependency(owner: IComputedObserver, parent: IDependency, value: unknown): IDependency {\r\n  const valueType = typeof value;\r\n  if (value == null || valueType === 'boolean' || valueType === 'number' || valueType === 'string' || valueType === 'symbol' || valueType === 'bigint' || typeof value === 'function') {\r\n    return;\r\n  }\r\n  if (Array.isArray(value)) {\r\n    return new ArrayDependency(owner, parent, value);\r\n  }\r\n  if (value instanceof Map) {\r\n    return new MapDependency(owner, parent, value);\r\n  }\r\n  if (value instanceof Set) {\r\n    return new SetDependency(owner, parent, value);\r\n  }\r\n  return new ObjectDependency(owner, parent, value as object);\r\n}\r\n","import {\r\n  ObserverLocator,\r\n  subscriberCollection,\r\n  connectable as $connectable,\r\n  Scope,\r\n  createOverrideContext,\r\n  Binding,\r\n  Disposable,\r\n  sourceContext\r\n} from 'aurelia-binding';\r\nimport {\r\n  ICallable,\r\n  IDependency,\r\n  IComputedOptions,\r\n  ComputedFromPropertyDescriptor\r\n} from './definitions';\r\nimport { ComputedExpression } from './computed-expression';\r\nimport { getDependency, releaseDep } from './dependency';\r\n\r\n// a deep observer needsd to be able to\r\n// - observe all properties, recursively without boundary\r\n// - detect a path of observer change\r\n\r\n/**\r\n * @internal The interface describes methods added by `connectable` & `subscriberCollection` decorators\r\n */\r\nexport interface ComputedObserver extends Binding {\r\n  _version: number;\r\n  addSubscriber(callable: (...args: any[]) => void): boolean;\r\n  addSubscriber(context: string, callable: ICallable): boolean;\r\n  addSubscriber(context: string | ICallable, callable?: ICallable): boolean;\r\n  callSubscribers(newValue: any, oldValue?: any): void;\r\n  hasSubscriber(context: string | ICallable, callable?: ICallable): boolean;\r\n  hasSubscribers(): boolean;\r\n  removeSubscriber(context: string | ICallable, callable?: ICallable): boolean;\r\n  observe(): void;\r\n  unobserve(all?: boolean): void;\r\n}\r\n\r\n// it looks better using @...(), so we cast to any instead of ClassDecorator\r\n// aurelia decorators support both usage: with and without parens\r\nconst connectable = $connectable as any;\r\n\r\n// by default, it does not support value converters & binding behaviors in the expressions\r\n// but maybe it should. TODO\r\nconst emptyLookupFunctions = {\r\n  valueConverters: name => null,\r\n  bindingBehaviors: name => null,\r\n};\r\n\r\nconst unset = {};\r\n\r\nexport class ComputedObserver {\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private isQueued: boolean = false;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private oldValue: any = unset;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private rootDeps: IDependency[];\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private readonly scope: Scope;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private readonly notifyingDeps: IDependency[] = [];\r\n\r\n  /**\r\n   * Only used when the observer is config to cache read\r\n   * @internal\r\n   */\r\n  private currentValue: any;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private $get: () => any;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private observing: boolean;\r\n\r\n  public deep: boolean;\r\n\r\n  public cache: boolean;\r\n\r\n  constructor(\r\n    public obj: object,\r\n    /**\r\n     * The expression that will be used to evaluate \r\n     */\r\n    // this expression has 2 purposes:\r\n    //  - a thin layer wrapping around getting/setting value of the targeted computed property\r\n    //  - an abstraction for dealing with a list of declared dependencies and their corresponding value\r\n    //    that uses existing Aurelia binding capabilities\r\n    public expression: ComputedExpression,\r\n    public observerLocator: ObserverLocator,\r\n    descriptor: PropertyDescriptor,\r\n    computedOptions: IComputedOptions\r\n  ) {\r\n    this.scope = { bindingContext: obj, overrideContext: createOverrideContext(obj) };\r\n    this.deep = computedOptions.deep;\r\n    this.cache = computedOptions.cache;\r\n    if (computedOptions.cache) {\r\n      const propertyName = expression.name;\r\n      const getterFn = (() => \r\n        // not observing === no track === no confidence that the current value is correct\r\n        this.observing ? this.currentValue : this.$get()\r\n      ) as ComputedFromPropertyDescriptor['get'];\r\n      getterFn.computed = computedOptions;\r\n      Object.defineProperty(obj, propertyName, {\r\n        get: getterFn,\r\n        set: descriptor.set,\r\n        configurable: true,\r\n        enumerable: true\r\n      });\r\n      this.$get = () => {\r\n        return descriptor.get.call(obj);\r\n      };\r\n    } else {\r\n      this.$get = () => {\r\n        return expression.evaluate(this.scope, emptyLookupFunctions);\r\n      };\r\n    }\r\n  }\r\n\r\n  getValue(): any {\r\n    return this.cache && this.observing\r\n      ? this.currentValue\r\n      : this.$get();\r\n  }\r\n\r\n  setValue(newValue: any): void {\r\n    // supports getter\r\n    this.expression.assign(this.scope, newValue, emptyLookupFunctions);\r\n  }\r\n\r\n  subscribe(context: string | ICallable, callable?: ICallable): void | Disposable {\r\n    if (!this.hasSubscribers()) {\r\n      this.oldValue = this.$get();\r\n      this.expression.connect(\r\n        /* @connectable makes this class behave as Binding */this,\r\n        this.scope\r\n      );\r\n      this.observeDeps();\r\n      this.observing = true;\r\n    }\r\n    this.addSubscriber(context, callable);\r\n    // scenario where this observer is created manually via ObserverLocator.getObserver\r\n    if (arguments.length === 1 && typeof context === 'function') {\r\n      return {\r\n        dispose: () => {\r\n          this.unsubscribe(context, callable);\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  unsubscribe(context: string | ICallable, callable?: ICallable): void {\r\n    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {\r\n      this.observing = false;\r\n      this.unobserveDeps();\r\n      this.notifyingDeps.length = 0;\r\n      this.unobserve(true);\r\n      this.oldValue = unset;\r\n    }\r\n  }\r\n\r\n  call() {\r\n    let newValue = this.currentValue = this.$get();\r\n    let oldValue = this.oldValue;\r\n    if (newValue !== oldValue) {\r\n      this.oldValue = newValue;\r\n      this.callSubscribers(newValue, oldValue === unset ? void 0 : oldValue);\r\n    }\r\n    if (this.isQueued) {\r\n      this.notifyingDeps.forEach(dep => {\r\n        if (!dep.connected) {\r\n          return;\r\n        }\r\n        dep.release();\r\n        dep.collect();\r\n        dep.observe();\r\n      });\r\n      this.isQueued = false;\r\n    } else {\r\n      this.unobserveDeps();\r\n      this.observeDeps();\r\n    }\r\n    this.notifyingDeps.length = 0;\r\n    this._version++;\r\n    this.expression.connect(/* @connectable makes this class behave as Binding */this, this.scope);\r\n    this.unobserve(false);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  handleChange(dep: IDependency): void {\r\n    const notifyingDeps = this.notifyingDeps;\r\n    if (notifyingDeps.indexOf(dep) === -1) {\r\n      notifyingDeps.push(dep);\r\n    }\r\n    if (this.isQueued) {\r\n      return;\r\n    }\r\n    this.isQueued = true;\r\n    this.observerLocator.taskQueue.queueMicroTask(this);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private observeDeps(): void {\r\n    const values = this.expression.getDeps(this.scope);\r\n    let rootDeps = this.rootDeps;\r\n    if (rootDeps == null) {\r\n      rootDeps = this.rootDeps = values.map(v => getDependency(this, null, v)).filter(Boolean);\r\n    }\r\n    rootDeps.forEach(dep => {\r\n      dep.collect();\r\n      dep.observe();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  private unobserveDeps(): void {\r\n    const rootDeps = this.rootDeps;\r\n    if (rootDeps != null) {\r\n      rootDeps.forEach(releaseDep);\r\n      this.rootDeps = void 0;\r\n    }\r\n  }\r\n}\r\n\r\n// use this instead of decorator to avoid extra generated code\r\nconnectable()(ComputedObserver);\r\nsubscriberCollection()(ComputedObserver);\r\n","import { Expression, Scope, Binding } from \"aurelia-binding\";\r\n\r\nexport class ComputedExpression extends Expression {\r\n\r\n  // this is to signal aurelia binding that it's ok trying to invoke .assign on this expression\r\n  isAssignable: boolean = true;\r\n\r\n  constructor(\r\n    public readonly name: string,\r\n    public readonly dependencies: Expression[]\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  evaluate(scope: Scope, lookupFunctions: any) {\r\n    return scope.bindingContext[this.name];\r\n  }\r\n\r\n  assign(scope: Scope, value: any, lookupFunctions: any): void {\r\n    scope.bindingContext[this.name] = value;\r\n  }\r\n\r\n  accept(visitor: any) {\r\n    throw new Error('not implemented');\r\n  }\r\n\r\n  connect(binding: Binding, scope: Scope) {\r\n    let dependencies = this.dependencies;\r\n    let i = dependencies.length;\r\n    while (i--) {\r\n      dependencies[i].connect(binding, scope);\r\n    }\r\n  }\r\n\r\n  getDeps(scope: Scope): any[] {\r\n    return this.dependencies.map(dep => dep.evaluate(scope));\r\n  }\r\n}","import {\r\n  FrameworkConfiguration,\r\n} from 'aurelia-framework';\r\nimport {\r\n  ObserverLocator,\r\n  Parser,\r\n  InternalPropertyObserver,\r\n} from 'aurelia-binding';\r\nimport {\r\n  ComputedFromPropertyDescriptor,\r\n  IProcessedComputedOptions,\r\n  IComputedOptions,\r\n} from './definitions';\r\nimport { ComputedObserver } from './computed-observer';\r\nimport { ComputedExpression } from './computed-expression';\r\n\r\nexport {\r\n  ComputedObserver,\r\n} from './computed-observer';\r\n\r\nexport {\r\n  IDependency\r\n} from './definitions';\r\n\r\nexport function configure(config: FrameworkConfiguration): void {\r\n  // need to run at post task to ensure we don't resolve everything too early\r\n  config.postTask(() => {\r\n    const container = config.container;\r\n    const observerLocator = container.get(ObserverLocator);\r\n    const parser = container.get(Parser);\r\n    // addAdapter is a hook from observer locator to deal with computed properties (getter/getter + setter)\r\n    observerLocator.addAdapter({\r\n      getObserver: (obj, propertyName, descriptor: ComputedFromPropertyDescriptor): InternalPropertyObserver => {\r\n        const computedOptions = descriptor.get.computed;\r\n        if (computedOptions) {\r\n          return createComputedObserver(obj, propertyName, descriptor, observerLocator, parser);\r\n        }\r\n        return null;\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nexport function deepComputedFrom(options: Partial<Omit<IComputedOptions, 'deep'>>): MethodDecorator;\r\nexport function deepComputedFrom(...expressions: string[]): MethodDecorator;\r\nexport function deepComputedFrom(...args: (Partial<IComputedOptions> | string)[]) {\r\n  return function (target: any, key: any, descriptor: PropertyDescriptor) {\r\n    (descriptor as ComputedFromPropertyDescriptor).get.computed = buildOptions(args, true);\r\n    return descriptor;\r\n  } as MethodDecorator;\r\n}\r\n\r\nexport function shallowComputedFrom(options: Partial<Omit<IComputedOptions, 'deep'>>): MethodDecorator;\r\nexport function shallowComputedFrom(...expressions: string[]): MethodDecorator;\r\nexport function shallowComputedFrom(...args: (Partial<IComputedOptions> | string)[]) {\r\n  return function (target: any, key: any, descriptor: PropertyDescriptor) {\r\n    (descriptor as ComputedFromPropertyDescriptor).get.computed = buildOptions(args, false);\r\n    return descriptor;\r\n  };\r\n}\r\n\r\nfunction buildOptions(args: (Partial<IComputedOptions> | string)[], deep: boolean): IComputedOptions {\r\n  const isConfigObject = args.length === 1 && typeof args[0] === 'object';\r\n  const deps = isConfigObject\r\n    ? (args[0] as IComputedOptions).deps || []\r\n    : (args as string[]);\r\n  const computedOptions: IComputedOptions = {\r\n    deep: deep,\r\n    deps: typeof deps === 'string' /* could be string when using config object, i.e deps: 'data' */\r\n      ? [deps]\r\n      : deps,\r\n    cache: isConfigObject ? (args[0] as IComputedOptions).cache : false\r\n  };\r\n  return computedOptions;\r\n}\r\n\r\nfunction createComputedObserver(\r\n  obj: any,\r\n  propertyName: string,\r\n  descriptor: ComputedFromPropertyDescriptor,\r\n  observerLocator: ObserverLocator,\r\n  parser: Parser,\r\n) {\r\n  const getterFn = descriptor.get;\r\n  const computedOptions = getterFn.computed as IProcessedComputedOptions;\r\n  let computedExpression = computedOptions.computedExpression;\r\n  if (!(computedExpression instanceof ComputedExpression)) {\r\n    let dependencies = computedOptions.deps;\r\n    let i = dependencies.length;\r\n    const parsedDeps = computedOptions.parsedDeps = Array(dependencies.length);\r\n    while (i--) {\r\n      parsedDeps[i] = parser.parse(dependencies[i]);\r\n    }\r\n    computedExpression = computedOptions.computedExpression = new ComputedExpression(propertyName, parsedDeps);\r\n  }\r\n\r\n  return new ComputedObserver(\r\n    obj,\r\n    computedExpression,\r\n    observerLocator,\r\n    descriptor,\r\n    computedOptions\r\n  );\r\n}\r\n"],"names":["$connectable","createOverrideContext","subscriberCollection","Expression","ObserverLocator","Parser"],"mappings":"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"}